[{"content":"如何高效地阅读 Python 代码？ 副标题：一个重要但很少被讨论的技能\n从网上看到这篇英文文章，感觉还不错，翻译了一下。Claude2 也有参与翻译😝\nAI摘要 这篇文章讨论了阅读代码的重要性以及一些高效阅读代码的策略。作者指出，阅读代码需要不同于编写代码的技能，并且认为相信自己可以轻松地阅读发布的解决方案是一个常见的误解。文章提供了一个练习的代码库，并展示了一些阅读代码的策略，如忽略函数定义和简化重复的代码块。作者还强调了使用IDE（集成开发环境）来帮助快速识别和关注代码的重要性。最后，文章提到了编写可读的代码以及学习阅读其他人的代码和第三方库的重要性。\n正文 阅读代码是一项重要的技能，但却不常被讨论。我认为存在这样的假设：如果你学会了相当好地编写代码，你也会自动学会有效地阅读代码。但是阅读代码需要不同于编写代码的技能，所以我不认为这是一个安全的假设。\n一位读者最近询问《Python Crash Course》中练习的一个解决方案。他说他的解决方案比我发布的简单许多，并说他们很难阅读发布的解决方案。我认为这是一个很好的例子，说明有效代码阅读的策略根本不明显。在这篇文章中，我将展示我们讨论的代码，以及一些比从头到尾逐行阅读更有效的处理代码的策略。\n练习内容 我们讨论的练习分两个部分。第一部分是:\n彩票\n制作一个包含10个数字和5个字母的列表或元组。从中随机选择4个数字或字母,打印出匹配这4个数字或字母的任意一注彩票可获奖。 这个练习旨在让人们练习使用Python标准库中的代码，比如 random.choice()函数。\n下面是后续练习:\n彩票分析\n你可以用一个循环来模拟刚刚建立的彩票游戏有多难中奖。建一个名为 my_ticket 的列表或元组。编写一个循环获取数字，直到抽中的彩票获奖为止，循环结束后打印循环了多少次才得到中奖的彩票。 在读者已经开始学习序列、循环、函数和类的时候，给他们布置这样一个既具体又开放的练习是很有意思的。对这样的练习任务制定解决方案，可以应用你所学的知识。\n发布的解决方案 如果你不习惯阅读代码，发布的解决方案会觉得有点长，但我全部贴出来：\nfrom random import choice def get_winning_ticket(possibilities): \u0026#34;\u0026#34;\u0026#34;Return a winning ticket from a set of possibilities.\u0026#34;\u0026#34;\u0026#34; winning_ticket = [] # We don\u0026#39;t want to repeat winning numbers or letters, so we\u0026#39;ll use a # while loop. while len(winning_ticket) \u0026lt; 4: pulled_item = choice(possibilities) # Only add the pulled item to the winning ticket if it hasn\u0026#39;t # already been pulled. if pulled_item not in winning_ticket: winning_ticket.append(pulled_item) return winning_ticket def check_ticket(played_ticket, winning_ticket): # Check all elements in the played ticket. If any are not in the # winning ticket, return False. for element in played_ticket: if element not in winning_ticket: return False # We must have a winning ticket! return True def make_random_ticket(possibilities): \u0026#34;\u0026#34;\u0026#34;Return a random ticket from a set of possibilities.\u0026#34;\u0026#34;\u0026#34; ticket = [] # We don\u0026#39;t want to repeat numbers or letters, so we\u0026#39;ll use a while loop. while len(ticket) \u0026lt; 4: pulled_item = choice(possibilities) # Only add the pulled item to the ticket if it hasn\u0026#39;t already # been pulled. if pulled_item not in ticket: ticket.append(pulled_item) return ticket possibilities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] winning_ticket = get_winning_ticket(possibilities) plays = 0 won = False # Let\u0026#39;s set a max number of tries, in case this takes forever! max_tries = 1_000_000 while not won: new_ticket = make_random_ticket(possibilities) won = check_ticket(new_ticket, winning_ticket) plays += 1 if plays \u0026gt;= max_tries: break if won: print(\u0026#34;We have a winning ticket!\u0026#34;) print(f\u0026#34;Your ticket: {new_ticket}\u0026#34;) print(f\u0026#34;Winning ticket: {winning_ticket}\u0026#34;) print(f\u0026#34;It only took {plays} tries to win!\u0026#34;) else: print(f\u0026#34;Tried {plays} times, without pulling a winner. :(\u0026#34;) print(f\u0026#34;Your ticket: {new_ticket}\u0026#34;) print(f\u0026#34;Winning ticket: {winning_ticket}\u0026#34;) 对刚开始学习编程的人来说，代码看起来有点多。包含空行和注释在内一共68行。\n我认为大多数没有太多经验或明确指导的人，倾向于从头到尾逐行阅读一个文件,同时试图理解其中的所有内容。有一个更好的方法。\n阅读策略：忽略函数定义 当通读一个新的代码库时，最好的策略之一是忽略函数定义。如果不包含任何函数定义，这个文件会变得多简单：\n... possibilities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] winning_ticket = get_winning_ticket(possibilities) plays = 0 won = False # Let\u0026#39;s set a max number of tries, in case this takes forever! max_tries = 1_000_000 while not won: new_ticket = make_random_ticket(possibilities) won = check_ticket(new_ticket, winning_ticket) plays += 1 if plays \u0026gt;= max_tries: break if won: print(\u0026#34;We have a winning ticket!\u0026#34;) print(f\u0026#34;Your ticket: {new_ticket}\u0026#34;) print(f\u0026#34;Winning ticket: {winning_ticket}\u0026#34;) print(f\u0026#34;It only took {plays} tries to win!\u0026#34;) else: print(f\u0026#34;Tried {plays} times, without pulling a winner. :(\u0026#34;) print(f\u0026#34;Your ticket: {new_ticket}\u0026#34;) print(f\u0026#34;Winning ticket: {winning_ticket}\u0026#34;) 现在我们可以更仔细地阅读这些代码了，但有另一个策略可以进一步减少混乱。\n阅读策略：简化重复的代码块 在从头到尾读代码之前，快速浏览一下代码库，看是否有什么可以简化的地方，无论是心理上还是在表面上。如果发现一些重复的块，你通常可以快速了解这些块在做什么，而忽略这些块的细节。\n这个文件底部有两个块，仅包含一堆 print() 调用。当我读这种代码时，我经常在心里忽略这些调用。所以，当我阅读一个像这样的文件时，这是我实际看到的：\npossibilities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] winning_ticket = get_winning_ticket(possibilities) plays = 0 won = False # Let\u0026#39;s set a max number of tries, in case this takes forever! max_tries = 1_000_000 while not won: new_ticket = make_random_ticket(possibilities) won = check_ticket(new_ticket, winning_ticket) plays += 1 if plays \u0026gt;= max_tries: break if won: # Print message about winning. else: # Print message about not winning. 这是一个比原始文件小得多的代码体。\n理解代码 现在我们终于可以专注于真正阅读代码了。知道这个程序是关于找到中奖彩票的,我会这样阅读剩下的代码:\n有一个名为 possibilities 的列表。这些必须是可以出现在彩票上的数字和字母。 变量 winning_ticket 似乎是从 possibilities 中抽取的一组中奖数字和字母。目前我不会阅读 get_winning_ticket() 函数体。现在我假设这个函数写得正确,它会从可能的字母和数字中返回一个随机选择。 我们看到定义了两个新变量 plays 和 won。plays 被设置为 0，所以这可能是彩票游戏进行的次数？won 是一个布尔值,最初被设置为 False。我猜没有人赢得彩票。 注释解释 max_tries 是试图生成中奖彩票的最大次数上限。 while 循环看起来是我们要阅读的最重要的代码部分。它似乎在做: 条件 while not won 意味着我们将一直循环，直到抽中中奖彩票。 在没有抽中中奖彩票之前,我们将继续生成 new_ticket。 每次生成新的彩票,我们都会调用 check_ticket() 来查看是否中奖。 每次循环我们会递增 plays 的次数。 如果超过 max_tries，我们会在没有中奖彩票的情况下结束循环。 循环结束后，我们会显示适当的结果消息。 这就是整个程序的核心部分。其余的代码只是实现细节，如果我们想进一步了解运行机制可以选择阅读。\n使用 IDE 阅读代码 在你练习了一段时间后，你可以跳过代码文件，只“看到”代码库中最重要的部分。这就是许多人高效阅读代码的方式。当人们的阅读速度快于你的想象时，那不是因为他们读了文件中的所有代码。相反，他们已经学会了快速识别哪些代码部分需要关注。\n你的 IDE 或编辑器可以帮助你学习这种技能。例如，在 Sublime Text 中此文件如下所示，函数定义和 print() 块被隐藏了:\n当你检查一个文件时，折叠你已经理解或识别为不太重要的部分，就只剩下你真正需要关注阅读的代码了。\n编写可读的代码 了解人们如何阅读代码可以帮助你编写更好的代码。例如，以有意义的方式将程序拆分成多个文件，可以让你和别人更容易理解自己的代码。\n在这个例子中，将函数移动到一个单独的文件会使主程序文件看起来像我们在这篇文章中关注的更简单的版本。这也将整个程序逻辑与特定任务的实现细节分离，例如检查单个票是否是赢家。\n这也提醒我们命名是编程的一个非常重要的部分。人们可能不会读取你的函数体，所以你的函数名应该清楚地传达它们的作用。你也希望变量名既简短又描述准确。\n总结 代码阅读是所有经验水平的程序员都需要的重要技能。知道如何高效阅读代码可以帮助你检查与当前工作相关的代码。这包括初学时的练习解决方案，但远不止初学。如果你可以高效阅读代码，你将更好地了解其他人的编程方式，以及他们解决各种问题的方法。随着 AI 工具重要性的日益增加，高效阅读代码是一个越来越关键的技能。你不能盲目接受 AI 工具生成的代码，所以快速准确地读取这些工具的输出是一个非常有用的技能。\n你还可以更有效地检查自己的代码，特别是当你重新查看前一段时间编写的代码时。你将能够更有效地参与代码审查，并且在工作或自己的项目中跳到新的代码库中会感到更舒服。你可以通过阅读你使用的第三方库和框架中的代码来学习很多东西，这些项目中的代码太多了，读不完。学习关注什么会让这些代码库更容易理解。\n阅读代码所需的技能和策略并未被系统地教授。人们倾向通过经验或与其他程序员的交流来学习这些技能。我希望这篇文章已经帮助你明白，其他人阅读代码不是比你快，而是他们正在使用你也可以练习和高效使用的策略。\n注意:后面的文章将讨论阅读更大规模代码库(例如重要第三方库和框架的源代码)的策略。如果你希望看到对某个开源代码库的介绍,请回复此邮件或联系我,让我知道你感兴趣的项目。\n原文：Reading code - by Eric Matthes\n","permalink":"http://tubaozi.top/posts/2023/reading_code/","summary":"如何高效地阅读 Python 代码？ 副标题：一个重要但很少被讨论的技能\n从网上看到这篇英文文章，感觉还不错，翻译了一下。Claude2 也有参与翻译😝\nAI摘要 这篇文章讨论了阅读代码的重要性以及一些高效阅读代码的策略。作者指出，阅读代码需要不同于编写代码的技能，并且认为相信自己可以轻松地阅读发布的解决方案是一个常见的误解。文章提供了一个练习的代码库，并展示了一些阅读代码的策略，如忽略函数定义和简化重复的代码块。作者还强调了使用IDE（集成开发环境）来帮助快速识别和关注代码的重要性。最后，文章提到了编写可读的代码以及学习阅读其他人的代码和第三方库的重要性。\n正文 阅读代码是一项重要的技能，但却不常被讨论。我认为存在这样的假设：如果你学会了相当好地编写代码，你也会自动学会有效地阅读代码。但是阅读代码需要不同于编写代码的技能，所以我不认为这是一个安全的假设。\n一位读者最近询问《Python Crash Course》中练习的一个解决方案。他说他的解决方案比我发布的简单许多，并说他们很难阅读发布的解决方案。我认为这是一个很好的例子，说明有效代码阅读的策略根本不明显。在这篇文章中，我将展示我们讨论的代码，以及一些比从头到尾逐行阅读更有效的处理代码的策略。\n练习内容 我们讨论的练习分两个部分。第一部分是:\n彩票\n制作一个包含10个数字和5个字母的列表或元组。从中随机选择4个数字或字母,打印出匹配这4个数字或字母的任意一注彩票可获奖。 这个练习旨在让人们练习使用Python标准库中的代码，比如 random.choice()函数。\n下面是后续练习:\n彩票分析\n你可以用一个循环来模拟刚刚建立的彩票游戏有多难中奖。建一个名为 my_ticket 的列表或元组。编写一个循环获取数字，直到抽中的彩票获奖为止，循环结束后打印循环了多少次才得到中奖的彩票。 在读者已经开始学习序列、循环、函数和类的时候，给他们布置这样一个既具体又开放的练习是很有意思的。对这样的练习任务制定解决方案，可以应用你所学的知识。\n发布的解决方案 如果你不习惯阅读代码，发布的解决方案会觉得有点长，但我全部贴出来：\nfrom random import choice def get_winning_ticket(possibilities): \u0026#34;\u0026#34;\u0026#34;Return a winning ticket from a set of possibilities.\u0026#34;\u0026#34;\u0026#34; winning_ticket = [] # We don\u0026#39;t want to repeat winning numbers or letters, so we\u0026#39;ll use a # while loop. while len(winning_ticket) \u0026lt; 4: pulled_item = choice(possibilities) # Only add the pulled item to the winning ticket if it hasn\u0026#39;t # already been pulled.","title":"如何高效地阅读 Python 代码？"},{"content":"一直在用ipython，有几个很重要的tip是今天才知道。\n使用python -m 打开ipython 因为ipython在安装时候已经写入到了python命令同目录下，所以平常直接ipython就可以进入了。但最近突发奇想，想用python -m ipython打开，却发现打不开\npython3 -m ipython # 报错：/xxxxxx/bin/python: No module named ipython 研究了好久才发现，原来需要有大小写！\npython3 -m IPython 那新问题又来了，我怎么知道我装的模块实际名字是什么呢？不去查谁知道ipython的正式名字是IPython呢。我们可以用pkgutil这个内置模块进行查询\nimport pkgutil for module in pkgutil.iter_modules(): if \u0026#34;ipython\u0026#34; in module.name.lower(): # 注意把模块名都小写化，同时去除这个条件也可以输出所有的模块名字 print(module.name) ipython -i 用法 之前没用过，在研究上面问题的时候看到了。这个参数的含义是加载一个py文件并进入交互系统，作用就是进入ipython之后，我们就可以直接调用py文件内定义的变量和函数了。\n比如有个文件script.py\n# script.py x = 10 y = 20 def add(a, b): return a + b 我们使用python3 -m IPython -i script.py 或者 ipython -i script.py 进入ipython\nIn [1]: x Out[1]: 10 In [2]: y Out[2]: 20 In [3]: print(add(3,5)) 8 未完待续 ","permalink":"http://tubaozi.top/posts/2023/ipython_tips/","summary":"一直在用ipython，有几个很重要的tip是今天才知道。\n使用python -m 打开ipython 因为ipython在安装时候已经写入到了python命令同目录下，所以平常直接ipython就可以进入了。但最近突发奇想，想用python -m ipython打开，却发现打不开\npython3 -m ipython # 报错：/xxxxxx/bin/python: No module named ipython 研究了好久才发现，原来需要有大小写！\npython3 -m IPython 那新问题又来了，我怎么知道我装的模块实际名字是什么呢？不去查谁知道ipython的正式名字是IPython呢。我们可以用pkgutil这个内置模块进行查询\nimport pkgutil for module in pkgutil.iter_modules(): if \u0026#34;ipython\u0026#34; in module.name.lower(): # 注意把模块名都小写化，同时去除这个条件也可以输出所有的模块名字 print(module.name) ipython -i 用法 之前没用过，在研究上面问题的时候看到了。这个参数的含义是加载一个py文件并进入交互系统，作用就是进入ipython之后，我们就可以直接调用py文件内定义的变量和函数了。\n比如有个文件script.py\n# script.py x = 10 y = 20 def add(a, b): return a + b 我们使用python3 -m IPython -i script.py 或者 ipython -i script.py 进入ipython\nIn [1]: x Out[1]: 10 In [2]: y Out[2]: 20 In [3]: print(add(3,5)) 8 未完待续 ","title":"关于IPython的几个冷知识"},{"content":"之前在平台上写博文，写完发布拉倒。现在自己建站，虽然自由了些，但牵扯到hugo、github提交和发布，麻烦了点，现在把流程规范和记录下来。\n1. 创建博文目录 goblog # alias命令，cd到博客所在的git仓库 # 新建博文markdown # 规范：posts/年份/博文标题目录/index.md -》最中路径在content下 # 年份是便于分类，博文标题做目录是为了让图片和md文件在一块，标题用英文，在url上好看些，md文档的front matter 的title字段可定义中文标题 hugo new posts/2023/博文标题/index.md 2. 使用 wolai + typora 编辑md文件 使用wolai编辑正文，使用 typora 编辑front matter和查看图片引用是否正常\n使用 wolai 编辑正文，然后以md格式导出，将该文件与上述index.md文件合并 使用 typora 打开文件并编辑： open -a typora content/posts/2023/博文标题/index.md 编辑front matter：\n注意编辑标题、分类、tag等， draft 改为 false， slug 是博文 url 的最后字段，如果为空默认就用当前目录，slug会默认做转换：将所有字母转换为小写字母，「-」替换空格，删除所有特殊字符 另外，还要在typora中设置「图片复制到./assets文件夹」\n3. 本地预览 写完后，可用以下命令预览，其中 -D 是显示草稿文章。\nhugo server -D 4. 提交到github # 一般情况下 git add -A git cm -m \u0026#34;添加博文xx\u0026#34; git push origin master # 可能需要代理 提交后，会激活github action自动发布，稍后即可在 tubaozi.top 看到了。\n5. 备份(不用了 2 中实际已经备份了) 将md文件导入到 wolai: -\u0026gt; Life/个人博客tubaozi.top/博文备份 下\n","permalink":"http://tubaozi.top/posts/2023/blog_write_best_practices/","summary":"之前在平台上写博文，写完发布拉倒。现在自己建站，虽然自由了些，但牵扯到hugo、github提交和发布，麻烦了点，现在把流程规范和记录下来。\n1. 创建博文目录 goblog # alias命令，cd到博客所在的git仓库 # 新建博文markdown # 规范：posts/年份/博文标题目录/index.md -》最中路径在content下 # 年份是便于分类，博文标题做目录是为了让图片和md文件在一块，标题用英文，在url上好看些，md文档的front matter 的title字段可定义中文标题 hugo new posts/2023/博文标题/index.md 2. 使用 wolai + typora 编辑md文件 使用wolai编辑正文，使用 typora 编辑front matter和查看图片引用是否正常\n使用 wolai 编辑正文，然后以md格式导出，将该文件与上述index.md文件合并 使用 typora 打开文件并编辑： open -a typora content/posts/2023/博文标题/index.md 编辑front matter：\n注意编辑标题、分类、tag等， draft 改为 false， slug 是博文 url 的最后字段，如果为空默认就用当前目录，slug会默认做转换：将所有字母转换为小写字母，「-」替换空格，删除所有特殊字符 另外，还要在typora中设置「图片复制到./assets文件夹」\n3. 本地预览 写完后，可用以下命令预览，其中 -D 是显示草稿文章。\nhugo server -D 4. 提交到github # 一般情况下 git add -A git cm -m \u0026#34;添加博文xx\u0026#34; git push origin master # 可能需要代理 提交后，会激活github action自动发布，稍后即可在 tubaozi.","title":"博文写作和发布最佳实践"},{"content":"一直想着建个自己的网站，顺便折腾点主题。前几天突发奇想注册了这个域名。顺手也把网站搭起来。调研了现在静态博客的情况，之前印象中的流行框架 HEXO 已然被 Hugo 盖住了风头。学习了下 Hugo，够简单，功能也够丰富。虽然网上 Hugo 搭建指南一大把，但我还是记录一下自己的使用过程，也作为第一篇正式博文。\n你可以在这篇博客中了解到：\nHugo 搭建静态博客方法 利用 github pages 托管网页 利用 github action 自动发布网页 一些建站过程中的 tips 安装Hugo Hugo的官网是https://gohugo.io/，另外有个中文文档网站https://gohugo.org/也可以参考。\n官方推荐了很多安装方式，但我觉得直接下载二进制文件最为方便(升级需要手动)，Hugo有标准版、扩展版两个版本，扩展版支持对 WebP 图像进行编码和使用嵌入式 LibSass 转译器将 Sass 转译到 CSS，官方也推荐使用扩展版。\n下载后，放到对应路径，添加到 PATH 环境变量，更方便使用。安装完后，使用以下命令进行验证：\nhugo version 使用Hugo 生成站点 即在指定路径下生成名为 sitename 的文件夹\nhugo new site /path/to/sitename 站点目录结构：\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml 创建文章 在content文件夹下新建posts文件夹并新建xx.md文档\nhugo new posts/xx.md 默认生成的 xx.md 内容和解释如下：\ntitle: \u0026#34;xx\u0026#34; # 网站显示的文章名字，可以与文件名不同 date: 2021-08-19T15:04:55+08:00 draft: true # 是否为草稿 # 下面两个默认没有，需要自己加 categories: [\u0026#34;互联网\u0026#34;] # 文章分类 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Github Pages\u0026#34;, \u0026#34;Github Actions\u0026#34;, \u0026#34;CI/CD\u0026#34;] # 文章标签 一般情况下，我们都要新建这些文件构建网站的骨架：\nabout.md archives.md search.md category.md 我一般会用文件夹组织 content 内的博文，比如我在posts下新建年份目录(2023/)进行归类，便于查找管理\n使用主题 可以去这里下载相关主题，并解压到theme目录下。我个人比较喜欢 PaperMod 主题，然后参考Cassius\u0026rsquo;s Blog进行了魔改。除了下载也可以 git clone，或者 git submodule 便于更新主题。\n使用主题需要在hugo.toml中添加theme: PaperMod才能启用\n运行Hugo 在你的站点根目录执行 Hugo 命令进行调试：\nhugo server -D --theme=PaperMod -D 是显示草稿文章，\u0026ndash;theme 是自行指定主题。然后打开 localhost:1313 就能欣赏自己的网站了。\n如果没问题，可以执行发布命令，发布正式网站内容到public目录：\nhugo hugo.yml 展示 hugo.yml做了很多配置，我的如下：\nbaseURL: \u0026#34;http://tubaozi.top/\u0026#34; title: 今是昨非 | 技术.生活.阅读.思考 paginate: 10 theme: PaperMod languageCode: zh defaultContentLanguage: zh enableInlineShortcodes: true enableRobotsTXT: true buildDrafts: false buildFuture: true buildExpired: false enableEmoji: true googleAnalytics: G-MZJS5SGFET minify: disableXML: true minifyOutput: true menu: main: - name: 🔎 搜索 url: search/ weight: 9 - name: ⏱️ 时间轴 url: archives weight: 10 - name: ⛩️ 分类 url: categories/ weight: 20 - name: 🧩 标签 url: tags/ weight: 30 - name: 🙋🏻‍♂️ 关于 url: about weight: 50 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. description: \u0026#34;个人博客\u0026#34; author: Beeta # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors # images: /favicon.ico defaultTheme: auto disableThemeToggle: false # ShowShareButtons: true # ShowReadingTime: true # disableSpecial1stPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: false ShowCodeCopyButtons: true ShowToc: true # home-info mode homeInfoParams: Title: \u0026#34;悟已往之不谏，知来者之可追\u0026#34; Content: \u0026gt; - ✨ 欢迎来到我的个人博客 - 🤔 我在这里分享技术、读书、生活还有思考。 socialIcons: - name: Github url: \u0026#34;https://github.com/Beeta\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; - name: email url: \u0026#34;mailto:zrc199021@163.com\u0026#34; label: # 左上角图标 text: \u0026#34;今是昨非\u0026#34; icon: \u0026#34;img/足迹.png\u0026#34; iconHeight: 35 markup: goldmark: renderer: unsafe: true 配置github actions 一般情况下，直接把public目录内容提交到你的xx.github.io仓库就能访问了。但这样做需要每次都提交一堆内容，比较繁琐。我们可以用 github actions 实现提交自己的 md 文档后自动执行发布的功能。\n原理：发布博文到仓库 -\u0026gt; 触发 actions 执行hugo命令并复制public下内容到指定仓库。\n有的人将博文和发布内容放到两个仓库，我则是发到了统一仓库的两个分支上：master 分支存md 文件，gh-pages 分支放发布后的内容。\ngithub actions 配置如下：\n点击 github 仓库页面Actions进行操作 最终会在仓库下生成.github/workflows目录内部有自己指定的配置文件，如github-pages.yaml。其中secrets.G_T是自己申请的(settings-\u0026gt;Actions secrets and variables-\u0026gt;Actions创建名为secrets.G_T的秘钥)\ngithub-pages.yaml内容如下\nname: GitHub Pages on: push: branches: - master # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.112.1\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} with: github_token: ${{ secrets.G_T }} publish_dir: ./public tips hugo.toml是最近版本新改的，之前是config.yml，两者都行，甚至hugo.yml也行。我比较习惯yaml语法，所以用最后这个\n每次发布都会重刷 public 里的所有文件，所以一些需要保留的文件需要放到static目录下\n可以在static下放 favicon.ico 文件，再网页标题栏显示图标 github页面展示需要的 CNAME文件也放在这 博客图片也可以放到 static 下，但是我个人习惯 md 文件和图片在同目录下。所以我的方式是每个博文一个文件夹，下面新建index.md作为博文主体。文件夹最好是英文，这样 url 编码好看些。\n生成的文章内部头部配置信息包括一些文章名称，时间之类的信息，可以事先在目录 archetypes/default.md 下使用模板，这样在用命令 hugo new 生成文章后会自动加上模板里的配置\n我的博客代码托管在：https://github.com/Beeta/beeta.github.io\n参考 下面的博客给了我很大帮助:\nhttps://www.yuweihung.com/ https://www.sulvblog.cn/ hugo博客搭建 | PaperMod主题 使用 Hugo+Github Actions 实现自动化部署博客 使用 Hugo 从 0 到 1 搭建个人博客 ","permalink":"http://tubaozi.top/posts/2023/create_blog_with_hugo/","summary":"一直想着建个自己的网站，顺便折腾点主题。前几天突发奇想注册了这个域名。顺手也把网站搭起来。调研了现在静态博客的情况，之前印象中的流行框架 HEXO 已然被 Hugo 盖住了风头。学习了下 Hugo，够简单，功能也够丰富。虽然网上 Hugo 搭建指南一大把，但我还是记录一下自己的使用过程，也作为第一篇正式博文。\n你可以在这篇博客中了解到：\nHugo 搭建静态博客方法 利用 github pages 托管网页 利用 github action 自动发布网页 一些建站过程中的 tips 安装Hugo Hugo的官网是https://gohugo.io/，另外有个中文文档网站https://gohugo.org/也可以参考。\n官方推荐了很多安装方式，但我觉得直接下载二进制文件最为方便(升级需要手动)，Hugo有标准版、扩展版两个版本，扩展版支持对 WebP 图像进行编码和使用嵌入式 LibSass 转译器将 Sass 转译到 CSS，官方也推荐使用扩展版。\n下载后，放到对应路径，添加到 PATH 环境变量，更方便使用。安装完后，使用以下命令进行验证：\nhugo version 使用Hugo 生成站点 即在指定路径下生成名为 sitename 的文件夹\nhugo new site /path/to/sitename 站点目录结构：\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml 创建文章 在content文件夹下新建posts文件夹并新建xx.md文档\nhugo new posts/xx.md 默认生成的 xx.md 内容和解释如下：\ntitle: \u0026#34;xx\u0026#34; # 网站显示的文章名字，可以与文件名不同 date: 2021-08-19T15:04:55+08:00 draft: true # 是否为草稿 # 下面两个默认没有，需要自己加 categories: [\u0026#34;互联网\u0026#34;] # 文章分类 tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Github Pages\u0026#34;, \u0026#34;Github Actions\u0026#34;, \u0026#34;CI/CD\u0026#34;] # 文章标签 一般情况下，我们都要新建这些文件构建网站的骨架：","title":"Hugo 静态博客搭建指南"},{"content":"关于我\n名字: Beeta 位置: 深圳 职业: 在某厂从事数据开发和分析工作 联系: enJjMTk5MDIxQDE2My5jb20= ","permalink":"http://tubaozi.top/about/","summary":"关于我\n名字: Beeta 位置: 深圳 职业: 在某厂从事数据开发和分析工作 联系: enJjMTk5MDIxQDE2My5jb20= ","title":"🙋🏻‍♂️关于"}]